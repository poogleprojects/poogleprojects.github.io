<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üèì 4-Player Neon Pong</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a1a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Segoe UI', 'Arial', sans-serif;
  }
  #scoreboard {
    display: flex;
    gap: 32px;
    margin-bottom: 10px;
    z-index: 2;
  }
  .score-item {
    text-align: center;
    font-size: 22px;
    font-weight: bold;
    text-shadow: 0 0 12px currentColor, 0 0 24px currentColor;
    letter-spacing: 2px;
  }
  .score-item .label { font-size: 13px; opacity: 0.7; }
  canvas {
    border-radius: 12px;
    box-shadow: 0 0 40px #0008, 0 0 80px #23d5ab22;
  }
  #info {
    color: #aaa;
    margin-top: 12px;
    font-size: 13px;
    text-align: center;
    z-index: 2;
    line-height: 1.7;
  }
  #info kbd {
    background: #222;
    border-radius: 4px;
    padding: 1px 7px;
    border: 1px solid #444;
    font-size: 12px;
  }
  #powerup-msg {
    position: fixed;
    top: 18%;
    left: 50%;
    transform: translateX(-50%);
    font-size: 28px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 20px #f5a623, 0 0 40px #f5a623;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 10;
    pointer-events: none;
  }
</style>
</head>
<body>
 
<div id="scoreboard">
  <div class="score-item" style="color:#ff3c7d"><div class="label">P1 (Left)</div><div id="s1">0</div></div>
  <div class="score-item" style="color:#23d5ab"><div class="label">P2 (Right)</div><div id="s2">0</div></div>
  <div class="score-item" style="color:#f5a623"><div class="label">P3 (Top)</div><div id="s3">0</div></div>
  <div class="score-item" style="color:#a259ff"><div class="label">P4 (Bottom)</div><div id="s4">0</div></div>
</div>
<canvas id="c"></canvas>
<div id="powerup-msg"></div>
<div id="info">
  <b>Controls:</b>
  P1 <kbd>W</kbd><kbd>S</kbd> &nbsp;
  P2 <kbd>‚Üë</kbd><kbd>‚Üì</kbd> &nbsp;
  P3 <kbd>A</kbd><kbd>D</kbd> &nbsp;
  P4 <kbd>‚Üê</kbd><kbd>‚Üí</kbd>
  <br>First to <b>10</b> wins! Collect ‚≠ê power-ups for special abilities!
</div>
 
<script>
// ============ SETUP ============
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 700, H = 700;
canvas.width = W; canvas.height = H;
 
const WINNING_SCORE = 10;
const PADDLE_THICK = 14;
const PADDLE_LEN = 110;
const PADDLE_SPEED = 7;
const BALL_R = 10;
const BALL_SPEED_INIT = 4.5;
const BALL_SPEED_MAX = 9;
const POWERUP_INTERVAL = 7000;
const POWERUP_DURATION = 5000;
 
// Colors
const COLORS = ['#ff3c7d', '#23d5ab', '#f5a623', '#a259ff'];
const GLOW = ['#ff3c7d88', '#23d5ab88', '#f5a62388', '#a259ff88'];
 
// ============ AUDIO (Web Audio API) ============
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function ensureAudio() { if (!audioCtx) audioCtx = new AudioCtx(); }
 
function playTone(freq, dur, type = 'square', vol = 0.13) {
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = vol;
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
}
function sndHit()    { playTone(520, 0.08, 'square', 0.12); }
function sndWall()   { playTone(320, 0.10, 'triangle', 0.09); }
function sndScore()  { playTone(180, 0.35, 'sawtooth', 0.13); }
function sndPowerup(){ playTone(880, 0.12, 'sine', 0.15); setTimeout(()=>playTone(1100,0.13,'sine',0.13),100); }
function sndWin()    { [0,100,200,300,400].forEach((d,i)=>setTimeout(()=>playTone(440+i*110,0.18,'sine',0.14),d)); }
 
// ============ STATE ============
let scores = [0,0,0,0];
let gameOver = false;
let winner = -1;
 
// Paddles: [left, right, top, bottom]
// left/right: x fixed, move y; top/bottom: y fixed, move x
let paddles = [
  { x: 6, y: H/2 - PADDLE_LEN/2, w: PADDLE_THICK, h: PADDLE_LEN, axis: 'y', color: COLORS[0], powerTimer: 0, bigPaddle: false },
  { x: W - 6 - PADDLE_THICK, y: H/2 - PADDLE_LEN/2, w: PADDLE_THICK, h: PADDLE_LEN, axis: 'y', color: COLORS[1], powerTimer: 0, bigPaddle: false },
  { x: W/2 - PADDLE_LEN/2, y: 6, w: PADDLE_LEN, h: PADDLE_THICK, axis: 'x', color: COLORS[2], powerTimer: 0, bigPaddle: false },
  { x: W/2 - PADDLE_LEN/2, y: H - 6 - PADDLE_THICK, w: PADDLE_LEN, h: PADDLE_THICK, axis: 'x', color: COLORS[3], powerTimer: 0, bigPaddle: false },
];
 
// Ball
let ball = { x: W/2, y: H/2, vx: 0, vy: 0, r: BALL_R, speed: BALL_SPEED_INIT, color: '#fff', trail: [] };
let balls = [ball];
 
// Particles
let particles = [];
 
// Power-ups
const POWERUP_TYPES = [
  { name: 'Big Paddle',  icon: 'üõ°Ô∏è', effect: 'bigpaddle' },
  { name: 'Multi Ball',  icon: 'üîÆ', effect: 'multiball' },
  { name: 'Speed Up',    icon: '‚ö°', effect: 'speedup' },
  { name: 'Slow Enemies',icon: 'üê¢', effect: 'slowenemy' },
];
let powerups = [];
let powerupTimer = 0;
let slowEnemyFor = -1;
let slowEnemyTimer = 0;
 
// Keys
let keys = {};
window.addEventListener('keydown', e => { keys[e.key] = true; ensureAudio(); });
window.addEventListener('keyup', e => { keys[e.key] = false; });
 
// ============ HELPERS ============
function rand(a, b) { return a + Math.random() * (b - a); }
function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
function showPowerMsg(txt) {
  const el = document.getElementById('powerup-msg');
  el.textContent = txt;
  el.style.opacity = 1;
  setTimeout(() => el.style.opacity = 0, 1200);
}
function resetBall(b) {
  b.x = W/2; b.y = H/2;
  b.speed = BALL_SPEED_INIT;
  let angle = rand(0, Math.PI*2);
  // Avoid too-flat angles
  while (Math.abs(Math.cos(angle)) < 0.25 || Math.abs(Math.sin(angle)) < 0.25) angle = rand(0, Math.PI*2);
  b.vx = Math.cos(angle) * b.speed;
  b.vy = Math.sin(angle) * b.speed;
  b.trail = [];
  b.color = '#fff';
}
function spawnParticles(x, y, color, count = 12) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: rand(-3, 3), vy: rand(-3, 3),
      life: rand(15, 35),
      maxLife: 35,
      color,
      r: rand(2, 5)
    });
  }
}
function updateScoreboard() {
  for (let i = 0; i < 4; i++) document.getElementById('s'+(i+1)).textContent = scores[i];
}
 
// ============ INIT ============
function init() {
  scores = [0,0,0,0];
  gameOver = false;
  winner = -1;
  balls = [ball];
  resetBall(ball);
  powerups = [];
  powerupTimer = 0;
  slowEnemyFor = -1;
  slowEnemyTimer = 0;
  particles = [];
  paddles.forEach(p => { p.powerTimer = 0; p.bigPaddle = false; });
  paddles[0].y = H/2 - PADDLE_LEN/2; paddles[0].h = PADDLE_LEN;
  paddles[1].y = H/2 - PADDLE_LEN/2; paddles[1].h = PADDLE_LEN;
  paddles[2].x = W/2 - PADDLE_LEN/2; paddles[2].w = PADDLE_LEN;
  paddles[3].x = W/2 - PADDLE_LEN/2; paddles[3].w = PADDLE_LEN;
  updateScoreboard();
}
 
// ============ POWER-UP SPAWN ============
function spawnPowerup() {
  const t = POWERUP_TYPES[Math.floor(Math.random()*POWERUP_TYPES.length)];
  powerups.push({
    x: rand(100, W-100), y: rand(100, H-100),
    r: 18,
    type: t,
    life: 400, // frames
    pulse: 0
  });
}
 
// ============ UPDATE ============
function update() {
  if (gameOver) return;
 
  // --- Paddle Movement ---
  let sp = PADDLE_SPEED;
  // P1 left: W/S
  let p1sp = (slowEnemyFor >= 0 && slowEnemyFor !== 0) ? sp * 0.5 : sp;
  if (keys['w'] || keys['W']) paddles[0].y -= p1sp;
  if (keys['s'] || keys['S']) paddles[0].y += p1sp;
  // P2 right: ArrowUp/ArrowDown
  let p2sp = (slowEnemyFor >= 0 && slowEnemyFor !== 1) ? sp * 0.5 : sp;
  if (keys['ArrowUp'])   paddles[1].y -= p2sp;
  if (keys['ArrowDown']) paddles[1].y += p2sp;
  // P3 top: A/D
  let p3sp = (slowEnemyFor >= 0 && slowEnemyFor !== 2) ? sp * 0.5 : sp;
  if (keys['a'] || keys['A']) paddles[2].x -= p3sp;
  if (keys['d'] || keys['D']) paddles[2].x += p3sp;
  // P4 bottom: ArrowLeft/ArrowRight
  let p4sp = (slowEnemyFor >= 0 && slowEnemyFor !== 3) ? sp * 0.5 : sp;
  if (keys['ArrowLeft'])  paddles[3].x -= p4sp;
  if (keys['ArrowRight']) paddles[3].x += p4sp;
 
  // Clamp paddles
  paddles[0].y = clamp(paddles[0].y, 0, H - paddles[0].h);
  paddles[1].y = clamp(paddles[1].y, 0, H - paddles[1].h);
  paddles[2].x = clamp(paddles[2].x, 0, W - paddles[2].w);
  paddles[3].x = clamp(paddles[3].x, 0, W - paddles[3].w);
 
  // Power-up timers
  paddles.forEach(p => {
    if (p.powerTimer > 0) {
      p.powerTimer--;
      if (p.powerTimer <= 0 && p.bigPaddle) {
        p.bigPaddle = false;
        if (p.axis === 'y') p.h = PADDLE_LEN;
        else p.w = PADDLE_LEN;
      }
    }
  });
  if (slowEnemyTimer > 0) { slowEnemyTimer--; if (slowEnemyTimer <= 0) slowEnemyFor = -1; }
 
  // --- Balls ---
  for (let bi = balls.length - 1; bi >= 0; bi--) {
    let b = balls[bi];
 
    // Trail
    b.trail.push({ x: b.x, y: b.y, color: b.color });
    if (b.trail.length > 22) b.trail.shift();
 
    b.x += b.vx;
    b.y += b.vy;
 
    // --- Paddle Collisions ---
    // Left paddle (P1)
    let p = paddles[0];
    if (b.vx < 0 && b.x - b.r < p.x + p.w && b.x + b.r > p.x && b.y > p.y && b.y < p.y + p.h) {
      b.vx = Math.abs(b.vx);
      b.x = p.x + p.w + b.r;
      let rel = (b.y - (p.y + p.h/2)) / (p.h/2);
      b.vy += rel * 2;
      b.speed = Math.min(b.speed + 0.12, BALL_SPEED_MAX);
      normalizeSpeed(b);
      b.color = COLORS[0];
      spawnParticles(b.x, b.y, COLORS[0]);
      sndHit();
    }
    // Right paddle (P2)
    p = paddles[1];
    if (b.vx > 0 && b.x + b.r > p.x && b.x - b.r < p.x + p.w && b.y > p.y && b.y < p.y + p.h) {
      b.vx = -Math.abs(b.vx);
      b.x = p.x - b.r;
      let rel = (b.y - (p.y + p.h/2)) / (p.h/2);
      b.vy += rel * 2;
      b.speed = Math.min(b.speed + 0.12, BALL_SPEED_MAX);
      normalizeSpeed(b);
      b.color = COLORS[1];
      spawnParticles(b.x, b.y, COLORS[1]);
      sndHit();
    }
    // Top paddle (P3)
    p = paddles[2];
    if (b.vy < 0 && b.y - b.r < p.y + p.h && b.y + b.r > p.y && b.x > p.x && b.x < p.x + p.w) {
      b.vy = Math.abs(b.vy);
      b.y = p.y + p.h + b.r;
      let rel = (b.x - (p.x + p.w/2)) / (p.w/2);
      b.vx += rel * 2;
      b.speed = Math.min(b.speed + 0.12, BALL_SPEED_MAX);
      normalizeSpeed(b);
      b.color = COLORS[2];
      spawnParticles(b.x, b.y, COLORS[2]);
      sndHit();
    }
    // Bottom paddle (P4)
    p = paddles[3];
    if (b.vy > 0 && b.y + b.r > p.y && b.y - b.r < p.y + p.h && b.x > p.x && b.x < p.x + p.w) {
      b.vy = -Math.abs(b.vy);
      b.y = p.y - b.r;
      let rel = (b.x - (p.x + p.w/2)) / (p.w/2);
      b.vx += rel * 2;
      b.speed = Math.min(b.speed + 0.12, BALL_SPEED_MAX);
      normalizeSpeed(b);
      b.color = COLORS[3];
      spawnParticles(b.x, b.y, COLORS[3]);
      sndHit();
    }
 
    // --- Scoring (ball exits a side) ---
    let scored = -1;
    if (b.x - b.r < 0)  scored = 0; // P1 missed
    if (b.x + b.r > W)  scored = 1; // P2 missed
    if (b.y - b.r < 0)  scored = 2; // P3 missed
    if (b.y + b.r > H)  scored = 3; // P4 missed
 
    if (scored >= 0) {
      spawnParticles(b.x, b.y, COLORS[scored], 25);
      // All OTHER players get a point
      for (let s = 0; s < 4; s++) { if (s !== scored) scores[s]++; }
      sndScore();
      updateScoreboard();
 
      // Check win
      for (let s = 0; s < 4; s++) {
        if (scores[s] >= WINNING_SCORE) { gameOver = true; winner = s; sndWin(); return; }
      }
 
      if (balls.length > 1) {
        balls.splice(bi, 1);
      } else {
        resetBall(b);
      }
    }
 
    // --- Power-up collection ---
    for (let pi = powerups.length - 1; pi >= 0; pi--) {
      let pw = powerups[pi];
      let dx = b.x - pw.x, dy = b.y - pw.y;
      if (Math.sqrt(dx*dx+dy*dy) < b.r + pw.r) {
        // Determine which player last hit (by ball color)
        let who = COLORS.indexOf(b.color);
        if (who < 0) who = Math.floor(Math.random()*4);
        applyPowerup(pw.type, who);
        spawnParticles(pw.x, pw.y, '#fff', 18);
        sndPowerup();
        powerups.splice(pi, 1);
      }
    }
  }
 
  // --- Power-up lifecycle ---
  powerupTimer++;
  if (powerupTimer > POWERUP_INTERVAL / 16.67) { powerupTimer = 0; spawnPowerup(); }
  for (let pi = powerups.length - 1; pi >= 0; pi--) {
    powerups[pi].life--;
    powerups[pi].pulse += 0.07;
    if (powerups[pi].life <= 0) powerups.splice(pi, 1);
  }
 
  // --- Particles ---
  for (let i = particles.length - 1; i >= 0; i--) {
    let pt = particles[i];
    pt.x += pt.vx; pt.y += pt.vy;
    pt.life--;
    if (pt.life <= 0) particles.splice(i, 1);
  }
}
 
function normalizeSpeed(b) {
  let mag = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
  if (mag > 0) { b.vx = b.vx/mag*b.speed; b.vy = b.vy/mag*b.speed; }
}
 
function applyPowerup(type, who) {
  let p = paddles[who];
  showPowerMsg(`${type.icon} Player ${who+1}: ${type.name}!`);
  switch (type.effect) {
    case 'bigpaddle':
      p.bigPaddle = true;
      if (p.axis === 'y') p.h = PADDLE_LEN * 1.7;
      else p.w = PADDLE_LEN * 1.7;
      p.powerTimer = POWERUP_DURATION / 16.67;
      break;
    case 'multiball':
      if (balls.length < 4) {
        let nb = { x: W/2, y: H/2, vx:0, vy:0, r: BALL_R, speed: BALL_SPEED_INIT, color: COLORS[who], trail: [] };
        resetBall(nb);
        nb.color = COLORS[who];
        balls.push(nb);
      }
      break;
    case 'speedup':
      balls.forEach(b => { b.speed = Math.min(b.speed + 2.2, BALL_SPEED_MAX); normalizeSpeed(b); });
      break;
    case 'slowenemy':
      slowEnemyFor = who;
      slowEnemyTimer = POWERUP_DURATION / 16.67;
      break;
  }
}
 
// ============ DRAW ============
function draw() {
  // Background
  ctx.fillStyle = '#0a0a1a';
  ctx.fillRect(0, 0, W, H);
 
  // Grid lines
  ctx.save();
  ctx.strokeStyle = '#ffffff08';
  ctx.lineWidth = 1;
  for (let i = 0; i < W; i += 35) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, H); ctx.stroke(); }
  for (let i = 0; i < H; i += 35) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(W, i); ctx.stroke(); }
  ctx.restore();
 
  // Center cross
  ctx.save();
  ctx.strokeStyle = '#ffffff12';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 10]);
  ctx.beginPath(); ctx.moveTo(W/2, 0); ctx.lineTo(W/2, H); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
 
  // Paddles
  paddles.forEach((p, i) => {
    ctx.save();
    ctx.shadowColor = COLORS[i];
    ctx.shadowBlur = 18;
    ctx.fillStyle = COLORS[i];
    ctx.beginPath();
    ctx.roundRect(p.x, p.y, p.w, p.h, 7);
    ctx.fill();
    // Inner glow
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#ffffff33';
    ctx.beginPath();
    ctx.roundRect(p.x + 2, p.y + 2, p.w - 4, p.h - 4, 5);
    ctx.fill();
    ctx.restore();
  });
 
  // Ball trails
  balls.forEach(b => {
    b.trail.forEach((t, i) => {
      let alpha = (i / b.trail.length) * 0.55;
      let r = b.r * (i / b.trail.length) * 0.9;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.shadowColor = t.color;
      ctx.shadowBlur = 14;
      ctx.fillStyle = t.color;
      ctx.beginPath();
      ctx.arc(t.x, t.y, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
 
    // Ball
    ctx.save();
    ctx.shadowColor = b.color;
    ctx.shadowBlur = 30;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    // Inner color ring
    ctx.strokeStyle = b.color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r + 2, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  });
 
  // Particles
  particles.forEach(pt => {
    let alpha = pt.life / pt.maxLife;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.shadowColor = pt.color;
    ctx.shadowBlur = 8;
    ctx.fillStyle = pt.color;
    ctx.beginPath();
    ctx.arc(pt.x, pt.y, pt.r * alpha, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  });
 
  // Power-ups
  powerups.forEach(pw => {
    let pulse = 1 + Math.sin(pw.pulse) * 0.18;
    let alpha = pw.life < 60 ? pw.life / 60 : 1;
    ctx.save();
    ctx.globalAlpha = alpha;
    // Glow ring
    ctx.shadowColor = '#f5a623';
    ctx.shadowBlur = 22;
    ctx.strokeStyle = '#f5a623';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.arc(pw.x, pw.y, pw.r * pulse, 0, Math.PI * 2);
    ctx.stroke();
    // BG circle
    ctx.fillStyle = '#181828cc';
    ctx.beginPath();
    ctx.arc(pw.x, pw.y, pw.r * pulse - 2, 0, Math.PI * 2);
    ctx.fill();
    // Icon
    ctx.shadowBlur = 0;
    ctx.font = `${22 * pulse}px serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(pw.type.icon, pw.x, pw.y + 1);
    ctx.restore();
  });
 
  // Game Over overlay
  if (gameOver) {
    ctx.save();
    ctx.fillStyle = 'rgba(10,10,26,0.82)';
    ctx.fillRect(0, 0, W, H);
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // Winner
    ctx.shadowColor = COLORS[winner];
    ctx.shadowBlur = 40;
    ctx.fillStyle = COLORS[winner];
    ctx.font = 'bold 54px Segoe UI, Arial, sans-serif';
    ctx.fillText(`üèÜ Player ${winner+1} Wins!`, W/2, H/2 - 30);
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#aaa';
    ctx.font = '22px Segoe UI, Arial, sans-serif';
    ctx.fillText('Press SPACE to play again', W/2, H/2 + 36);
    ctx.restore();
  }
}
 
// ============ GAME LOOP ============
function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}
 
// Restart
window.addEventListener('keydown', e => {
  if (gameOver && e.key === ' ') init();
});
 
init();
loop();
</script>
</body>
</html>
