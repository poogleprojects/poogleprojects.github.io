<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Small Worlds ‚Äì Board Game</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&family=Nunito:wght@400;700&display=swap');
 
  * { margin: 0; padding: 0; box-sizing: border-box; }
 
  body {
    font-family: 'Nunito', sans-serif;
    background: linear-gradient(135deg, #1a0533 0%, #2d1b69 40%, #1b3a4b 100%);
    color: #f0e6d3;
    min-height: 100vh;
    overflow-x: hidden;
  }
 
  h1, h2, h3 { font-family: 'MedievalSharp', cursive; }
 
  /* ---- HEADER ---- */
  header {
    text-align: center;
    padding: 18px 10px 8px;
    background: linear-gradient(180deg, rgba(0,0,0,.45) 0%, transparent 100%);
  }
  header h1 {
    font-size: 2.6rem;
    background: linear-gradient(90deg, #f9d423, #ff4e50, #fc913a, #f9d423);
    background-size: 300%;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: shimmer 4s linear infinite;
  }
  @keyframes shimmer { 0%{background-position:0%} 100%{background-position:300%} }
  header p { font-size: .95rem; opacity: .75; }
 
  /* ---- LAYOUT ---- */
  .game-container {
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    max-width: 1400px;
    margin: 0 auto;
    padding: 10px;
  }
  .panel {
    background: rgba(255,255,255,.07);
    border: 1px solid rgba(255,255,255,.12);
    border-radius: 14px;
    padding: 14px;
    backdrop-filter: blur(6px);
  }
  .left-panel  { flex: 0 0 240px; }
  .map-panel   { flex: 1 1 500px; min-width: 340px; }
  .right-panel { flex: 0 0 260px; }
 
  /* ---- INFO BAR ---- */
  .info-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 8px;
    padding: 8px 14px;
    background: rgba(0,0,0,.35);
    border-radius: 10px;
    font-size: .92rem;
  }
  .turn-badge {
    background: linear-gradient(135deg, #f9d423, #fc913a);
    color: #1a0533;
    font-weight: 700;
    padding: 3px 14px;
    border-radius: 20px;
  }
  .player-indicator {
    padding: 3px 14px;
    border-radius: 20px;
    font-weight: 700;
  }
 
  /* ---- BUTTONS ---- */
  .btn {
    display: inline-block;
    padding: 8px 18px;
    border: none;
    border-radius: 8px;
    font-family: 'Nunito', sans-serif;
    font-weight: 700;
    font-size: .9rem;
    cursor: pointer;
    transition: transform .12s, box-shadow .2s;
    color: #fff;
  }
  .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(0,0,0,.4); }
  .btn:active { transform: scale(.97); }
  .btn-primary   { background: linear-gradient(135deg, #6c5ce7, #a29bfe); }
  .btn-danger    { background: linear-gradient(135deg, #d63031, #e17055); }
  .btn-success   { background: linear-gradient(135deg, #00b894, #55efc4); color: #1a0533; }
  .btn-warning   { background: linear-gradient(135deg, #fdcb6e, #f9d423); color: #1a0533; }
  .btn-info      { background: linear-gradient(135deg, #0984e3, #74b9ff); }
  .btn-sm { padding: 5px 12px; font-size: .82rem; }
  .btn:disabled { opacity: .4; cursor: default; transform: none !important; box-shadow: none !important; }
 
  .btn-group { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
 
  /* ---- MAP ---- */
  svg.map {
    width: 100%;
    height: auto;
    border-radius: 12px;
    background: linear-gradient(180deg, #dfe6e9 0%, #b2bec3 100%);
    box-shadow: inset 0 0 30px rgba(0,0,0,.25);
  }
  .region {
    stroke: #2d3436;
    stroke-width: 1.6;
    cursor: pointer;
    transition: filter .15s, stroke .15s;
  }
  .region:hover { filter: brightness(1.18); stroke: #f9d423; stroke-width: 2.6; }
  .region.selected { stroke: #f9d423; stroke-width: 3; filter: brightness(1.25); }
  .region-label {
    font-size: 9px;
    fill: #2d3436;
    pointer-events: none;
    font-weight: 700;
    text-anchor: middle;
    dominant-baseline: central;
    text-shadow: 0 0 3px rgba(255,255,255,.7);
  }
  .token-count {
    font-size: 11px;
    fill: #fff;
    pointer-events: none;
    font-weight: 700;
    text-anchor: middle;
    dominant-baseline: central;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,.6));
  }
 
  /* ---- RACE COMBO SELECTOR ---- */
  .combo-list { max-height: 340px; overflow-y: auto; }
  .combo-card {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    margin-bottom: 6px;
    background: rgba(255,255,255,.06);
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    transition: border-color .15s, background .15s;
    position: relative;
  }
  .combo-card:hover { background: rgba(255,255,255,.12); border-color: rgba(249,212,35,.4); }
  .combo-card.disabled-card { opacity: .35; cursor: default; }
  .combo-card .emoji { font-size: 1.6rem; }
  .combo-card .details { flex: 1; }
  .combo-card .combo-name { font-weight: 700; font-size: .88rem; }
  .combo-card .combo-desc { font-size: .72rem; opacity: .7; }
  .combo-card .combo-tokens { font-size: .78rem; color: #fdcb6e; }
  .combo-card .coin-cost {
    position: absolute;
    top: 4px;
    right: 8px;
    background: #fdcb6e;
    color: #1a0533;
    font-size: .7rem;
    font-weight: 700;
    padding: 1px 7px;
    border-radius: 10px;
  }
  .combo-card .coins-on {
    position: absolute;
    bottom: 4px;
    right: 8px;
    font-size: .7rem;
    color: #ffeaa7;
  }
 
  /* ---- LOG ---- */
  .log {
    max-height: 180px;
    overflow-y: auto;
    font-size: .78rem;
    padding: 6px;
    background: rgba(0,0,0,.25);
    border-radius: 8px;
    margin-top: 6px;
  }
  .log p { margin-bottom: 3px; padding-left: 4px; border-left: 3px solid rgba(255,255,255,.15); }
 
  /* ---- SCORING ---- */
  .score-card {
    padding: 10px;
    margin-bottom: 8px;
    border-radius: 10px;
    font-size: .85rem;
  }
  .score-card .score-big { font-size: 1.8rem; font-family: 'MedievalSharp', cursive; }
 
  /* ---- MODAL ---- */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.7);
    z-index: 100;
    justify-content: center;
    align-items: center;
  }
  .modal-overlay.active { display: flex; }
  .modal {
    background: linear-gradient(160deg, #2d1b69, #1a0533);
    border: 2px solid rgba(249,212,35,.3);
    border-radius: 16px;
    padding: 28px;
    max-width: 520px;
    width: 90%;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,.6);
  }
  .modal h2 { margin-bottom: 12px; font-size: 1.8rem; color: #f9d423; }
  .modal p { margin-bottom: 16px; }
 
  /* ---- TERRAIN LEGEND ---- */
  .legend { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; font-size: .72rem; }
  .legend span {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 2px 8px;
    background: rgba(0,0,0,.3);
    border-radius: 6px;
  }
  .legend-swatch {
    width: 12px; height: 12px;
    border-radius: 3px;
    display: inline-block;
    border: 1px solid rgba(255,255,255,.3);
  }
 
  /* ---- RESPONSIVE ---- */
  @media (max-width: 900px) {
    .left-panel, .right-panel { flex: 1 1 100%; }
  }
 
  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: rgba(255,255,255,.2); border-radius: 3px; }
</style>
</head>
<body>
 
<header>
  <h1>‚öîÔ∏è Small Worlds ‚öîÔ∏è</h1>
  <p>Conquer territories. Decline races. Rule the realm!</p>
</header>
 
<div class="info-bar" id="infoBar">
  <span class="turn-badge" id="turnBadge">Turn 1 / 10</span>
  <span class="player-indicator" id="playerIndicator">Player 1's Turn</span>
  <span id="phaseLabel">Phase: Pick Race</span>
</div>
 
<div class="game-container">
 
  <!-- LEFT PANEL -->
  <div class="panel left-panel">
    <h3 style="margin-bottom:8px;">üè∞ Available Combos</h3>
    <div class="combo-list" id="comboList"></div>
    <div class="btn-group">
      <button class="btn btn-danger btn-sm" id="btnDecline" disabled>üíÄ Decline Race</button>
      <button class="btn btn-warning btn-sm" id="btnEndTurn" disabled>‚è≠ End Turn</button>
    </div>
    <div class="btn-group">
      <button class="btn btn-info btn-sm" id="btnRedeploy" disabled>üîÑ Redeploy</button>
      <button class="btn btn-success btn-sm" id="btnLastDie" disabled>üé≤ Final Conquest</button>
    </div>
    <div class="legend" id="legend"></div>
  </div>
 
  <!-- MAP PANEL -->
  <div class="panel map-panel">
    <svg class="map" id="mapSvg" viewBox="0 0 720 520"></svg>
  </div>
 
  <!-- RIGHT PANEL -->
  <div class="panel right-panel">
    <h3 style="margin-bottom:8px;">üìä Scoreboard</h3>
    <div id="scoreboard"></div>
    <h3 style="margin:12px 0 6px;">üìú Event Log</h3>
    <div class="log" id="log"></div>
  </div>
</div>
 
<!-- MODAL -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal" id="modal">
    <h2 id="modalTitle">Welcome</h2>
    <p id="modalBody">Loading...</p>
    <div id="modalButtons"></div>
  </div>
</div>
 
<script>
// ==============================
//  CONFIGURATION
// ==============================
const NUM_PLAYERS = 2;
const MAX_TURNS = 10;
const PLAYER_COLORS = ['#e74c3c','#3498db','#2ecc71','#f39c12'];
const PLAYER_NAMES = ['Player 1 üî¥','Player 2 üîµ','Player 3 üü¢','Player 4 üü°'];
const PLAYER_BG = ['rgba(231,76,60,.25)','rgba(52,152,219,.25)','rgba(46,204,113,.25)','rgba(243,156,18,.25)'];
const PLAYER_BORDER = ['#e74c3c','#3498db','#2ecc71','#f39c12'];
 
// ---- TERRAINS ----
const TERRAINS = {
  forest:    { color: '#27ae60', name: 'Forest',    emoji: 'üå≤' },
  hill:      { color: '#e67e22', name: 'Hill',      emoji: '‚õ∞Ô∏è' },
  farmland:  { color: '#f1c40f', name: 'Farmland',  emoji: 'üåæ' },
  swamp:     { color: '#6c5ce7', name: 'Swamp',     emoji: 'üê∏' },
  mountain:  { color: '#636e72', name: 'Mountain',   emoji: 'üèîÔ∏è' },
  water:     { color: '#0984e3', name: 'Water',     emoji: 'üåä' },
  magic:     { color: '#fd79a8', name: 'Magic',     emoji: '‚ú®' },
};
 
// ---- RACES ----
const RACES = [
  { name: 'Elves',      emoji: 'üßù', base: 6, desc: 'Tokens never truly lost (returned on defeat)', terrainBonus: null },
  { name: 'Dwarves',    emoji: '‚õèÔ∏è', base: 5, desc: '+1 coin per mine/mountain held',              terrainBonus: 'mountain' },
  { name: 'Orcs',       emoji: 'üëπ', base: 5, desc: '+1 coin per region conquered this turn',       terrainBonus: null },
  { name: 'Humans',     emoji: 'üßë', base: 5, desc: '+1 coin per farmland held',                    terrainBonus: 'farmland' },
  { name: 'Skeletons',  emoji: 'üíÄ', base: 6, desc: '+1 token per 2 regions conquered',             terrainBonus: null },
  { name: 'Wizards',    emoji: 'üßô', base: 5, desc: '+1 coin per magic region held',                terrainBonus: 'magic' },
  { name: 'Halflings',  emoji: 'üçñ', base: 6, desc: 'First 2 conquests need 1 less token',          terrainBonus: null },
  { name: 'Trolls',     emoji: 'üßå', base: 5, desc: '+1 defense in every occupied region',           terrainBonus: null },
  { name: 'Giants',     emoji: 'ü¶£', base: 5, desc: '-1 cost to conquer regions adjacent to mountains', terrainBonus: null },
  { name: 'Ratmen',     emoji: 'üêÄ', base: 8, desc: 'Start with many tokens',                       terrainBonus: null },
];
 
// ---- POWERS ----
const POWERS = [
  { name: 'Flying',      emoji: 'ü¶Ö', tokens: 5, desc: 'Can conquer any region (not just adjacent)' },
  { name: 'Mounted',     emoji: 'üê¥', tokens: 5, desc: '-1 cost to conquer hills & farmlands' },
  { name: 'Heroic',      emoji: 'üõ°Ô∏è', tokens: 5, desc: '2 regions are immune to conquest' },
  { name: 'Fortified',   emoji: 'üè∞', tokens: 4, desc: 'Place 1 fortress (+1 defense, +1 coin)' },
  { name: 'Wealthy',     emoji: 'üí∞', tokens: 4, desc: '+7 coins when first picked' },
  { name: 'Forest',      emoji: 'üå≤', tokens: 4, desc: '+1 coin per forest held' },
  { name: 'Swamp',       emoji: 'üê∏', tokens: 4, desc: '+1 coin per swamp held' },
  { name: 'Hill',        emoji: '‚õ∞Ô∏è', tokens: 4, desc: '+1 coin per hill held' },
  { name: 'Pillaging',   emoji: 'üî•', tokens: 5, desc: '+1 coin per non-empty region conquered' },
  { name: 'Diplomatic',  emoji: 'ü§ù', tokens: 5, desc: 'Choose a player; they can\'t attack you' },
  { name: 'Commando',    emoji: 'üó°Ô∏è', tokens: 4, desc: '-1 cost to conquer any region' },
  { name: 'Berserk',     emoji: 'üò§', tokens: 4, desc: 'Roll die before each conquest for bonus' },
];
 
// ==============================
//  MAP GENERATION (hex-ish grid)
// ==============================
const COLS = 8, ROWS = 6;
const HEX_W = 84, HEX_H = 78;
const OFFSET_X = 28, OFFSET_Y = 30;
let regions = [];
let adjacency = {};
 
function buildMap() {
  regions = [];
  adjacency = {};
  const terrainKeys = Object.keys(TERRAINS).filter(t => t !== 'water');
  let id = 0;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const x = OFFSET_X + c * HEX_W + (r % 2) * (HEX_W / 2);
      const y = OFFSET_Y + r * HEX_H * 0.82;
      // Edge regions have chance of water
      const isEdge = r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1;
      let terrain;
      if (isEdge && Math.random() < 0.25) terrain = 'water';
      else terrain = terrainKeys[Math.floor(Math.random() * terrainKeys.length)];
      // Hex points
      const hw = HEX_W / 2, hh = HEX_H / 2;
      const pts = [
        [x + hw * 0.5, y - hh],
        [x + hw * 1.3, y - hh * 0.35],
        [x + hw * 1.3, y + hh * 0.35],
        [x + hw * 0.5, y + hh],
        [x - hw * 0.3, y + hh * 0.35],
        [x - hw * 0.3, y - hh * 0.35],
      ];
      // Jitter for organic feel
      const jitteredPts = pts.map(([px, py]) => [
        px + (Math.random() - 0.5) * 10,
        py + (Math.random() - 0.5) * 8
      ]);
      regions.push({
        id, row: r, col: c, terrain, points: jitteredPts,
        cx: x + hw * 0.5, cy: y,
        owner: -1, tokens: terrain === 'mountain' ? 1 : 0, // mountains start with 1 "lost tribe"
        hasLostTribe: terrain !== 'water' && terrain !== 'mountain' ? (Math.random() < 0.35 ? true : false) : (terrain === 'mountain'),
        hasFortress: false,
        isEdge
      });
      id++;
    }
  }
  // If lost tribe, set tokens = 1
  regions.forEach(reg => { if (reg.hasLostTribe && reg.tokens === 0) reg.tokens = 1; });
  // Build adjacency
  regions.forEach(reg => { adjacency[reg.id] = []; });
  for (let i = 0; i < regions.length; i++) {
    for (let j = i + 1; j < regions.length; j++) {
      const a = regions[i], b = regions[j];
      const dist = Math.hypot(a.cx - b.cx, a.cy - b.cy);
      if (dist < HEX_W * 1.05) {
        adjacency[a.id].push(b.id);
        adjacency[b.id].push(a.id);
      }
    }
  }
}
 
// ==============================
//  GAME STATE
// ==============================
let state = {
  turn: 1,
  currentPlayer: 0,
  phase: 'pick', // pick | conquer | redeploy | done
  players: [],
  comboPool: [],
  conqueredThisTurn: 0,
  pillageCount: 0,
  firstConquests: 0,
  usedFinalDie: false,
  selectedRegion: -1,
  log: [],
};
 
function initPlayers() {
  state.players = [];
  for (let i = 0; i < NUM_PLAYERS; i++) {
    state.players.push({
      id: i,
      coins: 0,
      activeRace: null,
      activePower: null,
      activeTokens: 0,
      declinedRace: null,
      declinedRegions: [],
      hasDeclinedThisTurn: false,
    });
  }
}
 
function generateComboPool() {
  // Shuffle and pick 6 combos
  const shuffledRaces = [...RACES].sort(() => Math.random() - 0.5);
  const shuffledPowers = [...POWERS].sort(() => Math.random() - 0.5);
  state.comboPool = [];
  for (let i = 0; i < 6; i++) {
    state.comboPool.push({
      race: shuffledRaces[i % shuffledRaces.length],
      power: shuffledPowers[i % shuffledPowers.length],
      coinsOnCard: 0,
    });
  }
}
 
// ==============================
//  RENDERING
// ==============================
const mapSvg = document.getElementById('mapSvg');
const comboListEl = document.getElementById('comboList');
const scoreboardEl = document.getElementById('scoreboard');
const logEl = document.getElementById('log');
const infoBar = document.getElementById('infoBar');
const turnBadge = document.getElementById('turnBadge');
const playerIndicator = document.getElementById('playerIndicator');
const phaseLabel = document.getElementById('phaseLabel');
const btnDecline = document.getElementById('btnDecline');
const btnEndTurn = document.getElementById('btnEndTurn');
const btnRedeploy = document.getElementById('btnRedeploy');
const btnLastDie = document.getElementById('btnLastDie');
const legendEl = document.getElementById('legend');
 
function renderMap() {
  mapSvg.innerHTML = '';
  // Water background
  const bg = document.createElementNS('http://www.w3.org/2000/svg','rect');
  bg.setAttribute('width','720'); bg.setAttribute('height','520');
  bg.setAttribute('fill','#b2bec3'); bg.setAttribute('rx','12');
  mapSvg.appendChild(bg);
 
  regions.forEach(reg => {
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const poly = document.createElementNS('http://www.w3.org/2000/svg','polygon');
    poly.setAttribute('points', reg.points.map(p => p.join(',')).join(' '));
 
    let fill = TERRAINS[reg.terrain].color;
    if (reg.owner >= 0) {
      // Blend player color with terrain
      fill = blendColors(TERRAINS[reg.terrain].color, PLAYER_COLORS[reg.owner], 0.45);
    }
    poly.setAttribute('fill', fill);
    poly.classList.add('region');
    if (state.selectedRegion === reg.id) poly.classList.add('selected');
    poly.dataset.id = reg.id;
    poly.addEventListener('click', () => onRegionClick(reg.id));
    g.appendChild(poly);
 
    // Terrain emoji
    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
    label.setAttribute('x', reg.cx); label.setAttribute('y', reg.cy - 12);
    label.classList.add('region-label');
    label.textContent = TERRAINS[reg.terrain].emoji;
    label.style.fontSize = '14px';
    g.appendChild(label);
 
    // Token count / owner
    if (reg.owner >= 0 && reg.tokens > 0) {
      // Circle bg
      const circ = document.createElementNS('http://www.w3.org/2000/svg','circle');
      circ.setAttribute('cx', reg.cx); circ.setAttribute('cy', reg.cy + 10);
      circ.setAttribute('r', 12);
      circ.setAttribute('fill', PLAYER_COLORS[reg.owner]);
      circ.setAttribute('stroke', '#fff'); circ.setAttribute('stroke-width', '1.5');
      circ.style.pointerEvents = 'none';
      g.appendChild(circ);
      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
      txt.setAttribute('x', reg.cx); txt.setAttribute('y', reg.cy + 11);
      txt.classList.add('token-count');
      txt.textContent = reg.tokens;
      g.appendChild(txt);
    } else if (reg.hasLostTribe && reg.owner < 0) {
      // Lost tribe indicator
      const txt = document.createElementNS('http://www.w3.org/2000/svg','text');
      txt.setAttribute('x', reg.cx); txt.setAttribute('y', reg.cy + 12);
      txt.classList.add('region-label');
      txt.textContent = 'üë§';
      txt.style.fontSize = '13px';
      g.appendChild(txt);
    }
    if (reg.hasFortress) {
      const ft = document.createElementNS('http://www.w3.org/2000/svg','text');
      ft.setAttribute('x', reg.cx + 18); ft.setAttribute('y', reg.cy - 10);
      ft.classList.add('region-label');
      ft.textContent = 'üè∞';
      ft.style.fontSize = '12px';
      g.appendChild(ft);
    }
 
    mapSvg.appendChild(g);
  });
}
 
function renderCombos() {
  comboListEl.innerHTML = '';
  const p = currentPlayer();
  state.comboPool.forEach((combo, idx) => {
    const card = document.createElement('div');
    card.className = 'combo-card';
    const cost = idx; // First is free, then 1 coin, 2 coins...
    const canAfford = p.coins >= cost;
    const needsCombo = p.activeRace === null;
    if (!needsCombo || !canAfford || state.phase !== 'pick') card.classList.add('disabled-card');
    card.innerHTML = `
      <span class="emoji">${combo.race.emoji}</span>
      <div class="details">
        <div class="combo-name">${combo.power.emoji} ${combo.power.name} ${combo.race.name}</div>
        <div class="combo-desc">${combo.race.desc}</div>
        <div class="combo-desc" style="color:#74b9ff">${combo.power.desc}</div>
        <div class="combo-tokens">Tokens: ${combo.race.base + combo.power.tokens}</div>
      </div>
      ${cost > 0 ? `<span class="coin-cost">üí∞ ${cost}</span>` : ''}
      ${combo.coinsOnCard > 0 ? `<span class="coins-on">+${combo.coinsOnCard} üí∞</span>` : ''}
    `;
    if (needsCombo && canAfford && state.phase === 'pick') {
      card.addEventListener('click', () => pickCombo(idx));
    }
    comboListEl.appendChild(card);
  });
}
 
function renderScoreboard() {
  scoreboardEl.innerHTML = '';
  state.players.forEach(p => {
    const ownedCount = regions.filter(r => r.owner === p.id).length;
    const div = document.createElement('div');
    div.className = 'score-card';
    div.style.background = PLAYER_BG[p.id];
    div.style.borderLeft = `4px solid ${PLAYER_BORDER[p.id]}`;
    div.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <span>${PLAYER_NAMES[p.id]}</span>
        <span class="score-big">üí∞ ${p.coins}</span>
      </div>
      <div style="font-size:.78rem;opacity:.7;">
        ${p.activeRace ? `Active: ${p.activeRace.emoji} ${p.activeRace.name} (${p.activeTokens} tokens in hand)` : 'No active race'}
        ${p.declinedRace ? `<br>Declined: ${p.declinedRace.emoji} ${p.declinedRace.name}` : ''}
        <br>Regions: ${ownedCount}
      </div>
    `;
    scoreboardEl.appendChild(div);
  });
}
 
function renderInfoBar() {
  turnBadge.textContent = `Turn ${state.turn} / ${MAX_TURNS}`;
  const p = currentPlayer();
  playerIndicator.textContent = PLAYER_NAMES[state.currentPlayer];
  playerIndicator.style.background = PLAYER_BG[state.currentPlayer];
  playerIndicator.style.border = `2px solid ${PLAYER_BORDER[state.currentPlayer]}`;
  const phaseNames = { pick: 'üé¥ Pick a Race', conquer: '‚öîÔ∏è Conquer', redeploy: 'üîÑ Redeploy Tokens', done: '‚úÖ Done' };
  phaseLabel.textContent = `Phase: ${phaseNames[state.phase] || state.phase}`;
}
 
function renderButtons() {
  const p = currentPlayer();
  btnDecline.disabled = !(state.phase === 'pick' && p.activeRace !== null);
  btnEndTurn.disabled = state.phase === 'pick' || state.phase === 'done';
  btnRedeploy.disabled = state.phase !== 'conquer';
  btnLastDie.disabled = !(state.phase === 'conquer' && !state.usedFinalDie && state.conqueredThisTurn > 0);
}
 
function renderLegend() {
  legendEl.innerHTML = Object.entries(TERRAINS).map(([k,v]) =>
    `<span><span class="legend-swatch" style="background:${v.color}"></span>${v.emoji} ${v.name}</span>`
  ).join('');
}
 
function addLog(msg) {
  state.log.unshift(msg);
  if (state.log.length > 60) state.log.pop();
  logEl.innerHTML = state.log.map(m => `<p>${m}</p>`).join('');
}
 
function renderAll() {
  renderMap();
  renderCombos();
  renderScoreboard();
  renderInfoBar();
  renderButtons();
}
 
// ==============================
//  HELPERS
// ==============================
function currentPlayer() { return state.players[state.currentPlayer]; }
 
function blendColors(c1, c2, t) {
  const h2r = hex => [parseInt(hex.slice(1,3),16), parseInt(hex.slice(3,5),16), parseInt(hex.slice(5,7),16)];
  const [r1,g1,b1] = h2r(c1), [r2,g2,b2] = h2r(c2);
  const r = Math.round(r1*(1-t)+r2*t), g = Math.round(g1*(1-t)+g2*t), b = Math.round(b1*(1-t)+b2*t);
  return `rgb(${r},${g},${b})`;
}
 
function getPlayerRegions(pid) { return regions.filter(r => r.owner === pid); }
 
function isAdjacentToOwned(regId, pid) {
  const owned = getPlayerRegions(pid);
  if (owned.length === 0) return regions[regId].isEdge; // First conquest must be border
  return adjacency[regId].some(adj => regions[adj].owner === pid);
}
 
function conquestCost(regId) {
  const reg = regions[regId];
  let cost = 2; // Base
  cost += reg.tokens; // Defenders
  if (reg.hasLostTribe && reg.owner < 0) cost += 1;
  if (reg.terrain === 'mountain') cost += 1;
  if (reg.hasFortress) cost += 1;
  // Troll defense
  if (reg.owner >= 0) {
    const defender = state.players[reg.owner];
    if (defender.activeRace && defender.activeRace.name === 'Trolls') cost += 1;
  }
  return Math.max(1, cost);
}
 
function applyPowerModifier(cost, regId, player) {
  const reg = regions[regId];
  if (player.activePower) {
    if (player.activePower.name === 'Commando') cost -= 1;
    if (player.activePower.name === 'Mounted' && (reg.terrain === 'hill' || reg.terrain === 'farmland')) cost -= 1;
    if (player.activePower.name === 'Hill' && reg.terrain === 'hill') cost -= 0; // scoring only
  }
  if (player.activeRace) {
    if (player.activeRace.name === 'Halflings' && state.firstConquests < 2) cost -= 1;
    if (player.activeRace.name === 'Giants') {
      const adjToMtn = adjacency[regId].some(a => regions[a].terrain === 'mountain' && regions[a].owner === player.id);
      if (adjToMtn) cost -= 1;
    }
  }
  return Math.max(1, cost);
}
 
function canFly(player) {
  return player.activePower && player.activePower.name === 'Flying';
}
 
// ==============================
//  GAME LOGIC
// ==============================
function pickCombo(idx) {
  const p = currentPlayer();
  const cost = idx;
  if (p.coins < cost) return;
 
  // Pay cost; coins go on skipped combos
  p.coins -= cost;
  for (let i = 0; i < idx; i++) {
    state.comboPool[i].coinsOnCard += 1;
  }
 
  const combo = state.comboPool.splice(idx, 1)[0];
  p.activeRace = combo.race;
  p.activePower = combo.power;
  p.activeTokens = combo.race.base + combo.power.tokens;
  p.coins += combo.coinsOnCard; // Collect coins on the card
 
  // Wealthy bonus
  if (combo.power.name === 'Wealthy') p.coins += 7;
 
  addLog(`${PLAYER_NAMES[p.id]} picked <b>${combo.power.emoji} ${combo.power.name} ${combo.race.emoji} ${combo.race.name}</b> (${p.activeTokens} tokens)`);
 
  // Refill combo pool
  refillComboPool();
 
  state.phase = 'conquer';
  state.conqueredThisTurn = 0;
  state.pillageCount = 0;
  state.firstConquests = 0;
  state.usedFinalDie = false;
  renderAll();
}
 
function refillComboPool() {
  const allRaces = [...RACES].sort(() => Math.random() - 0.5);
  const allPowers = [...POWERS].sort(() => Math.random() - 0.5);
  while (state.comboPool.length < 6) {
    const race = allRaces[state.comboPool.length % allRaces.length];
    const power = allPowers[state.comboPool.length % allPowers.length];
    // Make sure we don't duplicate exact combos
    state.comboPool.push({ race, power, coinsOnCard: 0 });
  }
}
 
function declineRace() {
  const p = currentPlayer();
  if (!p.activeRace) return;
 
  addLog(`${PLAYER_NAMES[p.id]} put <b>${p.activeRace.emoji} ${p.activeRace.name}</b> in decline!`);
 
  // Remove old declined regions
  if (p.declinedRace) {
    regions.forEach(r => {
      if (p.declinedRegions.includes(r.id)) {
        r.owner = -1;
        r.tokens = 0;
      }
    });
  }
 
  // Current regions become declined (keep 1 token each)
  p.declinedRegions = getPlayerRegions(p.id).map(r => r.id);
  p.declinedRegions.forEach(rid => { regions[rid].tokens = 1; });
 
  p.declinedRace = p.activeRace;
  p.activeRace = null;
  p.activePower = null;
  p.activeTokens = 0;
  p.hasDeclinedThisTurn = true;
 
  state.phase = 'pick';
  renderAll();
}
 
function onRegionClick(regId) {
  const reg = regions[regId];
  const p = currentPlayer();
 
  if (state.phase === 'conquer') {
    attemptConquest(regId);
  } else if (state.phase === 'redeploy') {
    attemptRedeploy(regId);
  } else {
    // Just select for info
    state.selectedRegion = regId;
    renderAll();
  }
}
 
function attemptConquest(regId) {
  const reg = regions[regId];
  const p = currentPlayer();
 
  // Can't conquer water
  if (reg.terrain === 'water') { addLog('‚ùå Cannot conquer water!'); return; }
  // Can't conquer own region
  if (reg.owner === p.id) { addLog('‚ùå You already own this region!'); return; }
 
  // Adjacency check (unless flying or first conquest on border)
  if (!canFly(p) && !isAdjacentToOwned(regId, p.id)) {
    addLog('‚ùå Must conquer adjacent region (or border if first)!');
    return;
  }
  // Flying: first must still be border if no regions owned
  if (canFly(p) && getPlayerRegions(p.id).length === 0 && !reg.isEdge) {
    addLog('‚ùå First conquest must be a border region!');
    return;
  }
 
  let cost = conquestCost(regId);
  cost = applyPowerModifier(cost, regId, p);
 
  if (p.activeTokens < cost) {
    addLog(`‚ùå Need ${cost} tokens, you have ${p.activeTokens}. Try üé≤ Final Conquest!`);
    return;
  }
 
  // Success!
  const defenderId = reg.owner;
  const wasNonEmpty = reg.tokens > 0 || reg.hasLostTribe;
 
  // Defender loses tokens
  if (defenderId >= 0) {
    const defender = state.players[defenderId];
    let lostTokens = reg.tokens;
    // Elves get tokens back
    if (defender.activeRace && defender.activeRace.name === 'Elves') {
      defender.activeTokens += lostTokens;
      addLog(`üßù Elves recover ${lostTokens} tokens!`);
    } else {
      // 1 token returned to hand, rest lost
      if (lostTokens > 0) defender.activeTokens += Math.max(0, lostTokens - 1);
    }
  }
 
  reg.owner = p.id;
  reg.tokens = cost;
  reg.hasLostTribe = false;
  reg.hasFortress = false;
  p.activeTokens -= cost;
 
  state.conqueredThisTurn++;
  state.firstConquests++;
 
  // Pillaging
  if (wasNonEmpty) state.pillageCount++;
 
  // Skeletons bonus
  if (p.activeRace && p.activeRace.name === 'Skeletons' && state.conqueredThisTurn % 2 === 0) {
    p.activeTokens += 1;
    addLog(`üíÄ Skeletons gain a bonus token!`);
  }
 
  addLog(`${PLAYER_NAMES[p.id]} conquered region ${regId} (${TERRAINS[reg.terrain].emoji} ${TERRAINS[reg.terrain].name}) for ${cost} tokens.`);
  state.selectedRegion = regId;
  renderAll();
}
 
function attemptFinalDie() {
  if (state.usedFinalDie) return;
  state.usedFinalDie = true;
  const p = currentPlayer();
 
  // Pick a target
  // Find all conquerable regions
  const targets = regions.filter(r => {
    if (r.terrain === 'water' || r.owner === p.id) return false;
    if (canFly(p)) return true;
    return isAdjacentToOwned(r.id, p.id);
  });
 
  if (targets.length === 0) {
    addLog('üé≤ No valid targets for final conquest!');
    renderAll();
    return;
  }
 
  showModal('üé≤ Final Conquest', 'Click a region to attempt final conquest with dice!<br>You have ' + p.activeTokens + ' tokens + dice roll (0-3).', [
    { text: 'Cancel', class: 'btn btn-danger', action: () => { state.usedFinalDie = false; hideModal(); } }
  ]);
 
  state.phase = 'final_conquest';
  renderAll();
}
 
function attemptFinalConquest(regId) {
  const reg = regions[regId];
  const p = currentPlayer();
 
  if (reg.terrain === 'water' || reg.owner === p.id) return;
  if (!canFly(p) && !isAdjacentToOwned(regId, p.id)) return;
 
  const roll = Math.floor(Math.random() * 4); // 0, 1, 2, or 3
  let cost = conquestCost(regId);
  cost = applyPowerModifier(cost, regId, p);
 
  const effective = p.activeTokens + roll;
  addLog(`üé≤ Rolled ${roll}! Effective strength: ${effective} vs cost ${cost}`);
 
  if (effective >= cost) {
    // Conquer with all remaining tokens
    const defenderId = reg.owner;
    if (defenderId >= 0) {
      const defender = state.players[defenderId];
      let lost = reg.tokens;
      if (defender.activeRace && defender.activeRace.name === 'Elves') {
        defender.activeTokens += lost;
      } else if (lost > 0) {
        defender.activeTokens += Math.max(0, lost - 1);
      }
    }
    reg.owner = p.id;
    reg.tokens = Math.max(1, p.activeTokens);
    reg.hasLostTribe = false;
    reg.hasFortress = false;
    p.activeTokens = 0;
    state.conqueredThisTurn++;
    if (reg.tokens > 0) state.pillageCount++;
    addLog(`‚úÖ Final conquest of region ${regId} succeeded!`);
  } else {
    addLog(`‚ùå Final conquest failed!`);
  }
 
  hideModal();
  state.phase = 'conquer';
  renderAll();
}
 
function startRedeploy() {
  const p = currentPlayer();
  // Pick up all tokens from owned regions
  const ownedRegions = getPlayerRegions(p.id);
  let totalTokens = p.activeTokens;
  ownedRegions.forEach(r => {
    totalTokens += r.tokens;
    r.tokens = 0;
  });
  p.activeTokens = totalTokens;
  state.phase = 'redeploy';
  addLog(`üîÑ ${PLAYER_NAMES[p.id]} is redeploying ${totalTokens} tokens...`);
  renderAll();
}
 
function attemptRedeploy(regId) {
  const reg = regions[regId];
  const p = currentPlayer();
 
  if (reg.owner !== p.id) {
    addLog('‚ùå Can only redeploy to your own regions!');
    return;
  }
  if (p.activeTokens <= 0) {
    addLog('‚ùå No more tokens to place!');
    return;
  }
 
  reg.tokens += 1;
  p.activeTokens -= 1;
  addLog(`Placed 1 token on region ${regId}. ${p.activeTokens} remaining.`);
 
  // Auto-finish when 0 tokens left
  if (p.activeTokens <= 0) {
    finishRedeploy();
  }
  renderAll();
}
 
function finishRedeploy() {
  const p = currentPlayer();
  // Make sure all owned regions have at least 1
  const empty = getPlayerRegions(p.id).filter(r => r.tokens === 0);
  if (empty.length > 0 && p.activeTokens > 0) {
    addLog('‚ö†Ô∏è Some regions are empty! Place tokens there first.');
    return;
  }
  // Abandon empty regions
  getPlayerRegions(p.id).forEach(r => {
    if (r.tokens === 0) {
      r.owner = -1;
      addLog(`Region ${r.id} abandoned (no tokens).`);
    }
  });
  state.phase = 'conquer';
  addLog(`‚úÖ Redeployment complete.`);
  renderAll();
}
 
function endTurn() {
  const p = currentPlayer();
 
  // Score phase
  let income = 0;
  const ownedRegions = getPlayerRegions(p.id);
  income += ownedRegions.length; // 1 per region
 
  // Race bonuses
  if (p.activeRace) {
    if (p.activeRace.name === 'Dwarves') {
      income += ownedRegions.filter(r => r.terrain === 'mountain').length;
    }
    if (p.activeRace.name === 'Humans') {
      income += ownedRegions.filter(r => r.terrain === 'farmland').length;
    }
    if (p.activeRace.name === 'Wizards') {
      income += ownedRegions.filter(r => r.terrain === 'magic').length;
    }
    if (p.activeRace.name === 'Orcs') {
      income += state.conqueredThisTurn;
    }
  }
 
  // Power bonuses
  if (p.activePower) {
    if (p.activePower.name === 'Forest') income += ownedRegions.filter(r => r.terrain === 'forest').length;
    if (p.activePower.name === 'Swamp') income += ownedRegions.filter(r => r.terrain === 'swamp').length;
    if (p.activePower.name === 'Hill') income += ownedRegions.filter(r => r.terrain === 'hill').length;
    if (p.activePower.name === 'Pillaging') income += state.pillageCount;
    if (p.activePower.name === 'Fortified') income += ownedRegions.filter(r => r.hasFortress).length;
  }
 
  // Declined regions income
  if (p.declinedRace) {
    const declinedOwned = regions.filter(r => p.declinedRegions.includes(r.id) && r.owner === p.id);
    income += declinedOwned.length;
  }
 
  p.coins += income;
  addLog(`üí∞ ${PLAYER_NAMES[p.id]} earns ${income} coins! (Total: ${p.coins})`);
 
  // Fortified: place fortress
  if (p.activePower && p.activePower.name === 'Fortified') {
    const noFort = ownedRegions.filter(r => !r.hasFortress);
    if (noFort.length > 0) {
      const pick = noFort[Math.floor(Math.random() * noFort.length)];
      pick.hasFortress = true;
      addLog(`üè∞ Fortress placed in region ${pick.id}!`);
    }
  }
 
  // Next player
  state.currentPlayer = (state.currentPlayer + 1) % NUM_PLAYERS;
 
  // If we've cycled back to player 0, increment turn
  if (state.currentPlayer === 0) {
    state.turn++;
    if (state.turn > MAX_TURNS) {
      endGame();
      return;
    }
  }
 
  // Reset for next player
  const next = currentPlayer();
  next.hasDeclinedThisTurn = false;
  state.conqueredThisTurn = 0;
  state.pillageCount = 0;
  state.firstConquests = 0;
  state.usedFinalDie = false;
  state.selectedRegion = -1;
 
  if (next.activeRace) {
    // Gather tokens: tokens in hand + 1 from each region (keep 1 on region)
    let gather = next.activeTokens;
    getPlayerRegions(next.id).forEach(r => {
      if (r.tokens > 1) {
        gather += r.tokens - 1;
        r.tokens = 1;
      }
    });
    next.activeTokens = gather;
    state.phase = 'conquer';
    addLog(`${PLAYER_NAMES[next.id]}'s turn! ${next.activeRace.emoji} ${next.activeRace.name} with ${next.activeTokens} tokens.`);
  } else {
    state.phase = 'pick';
    addLog(`${PLAYER_NAMES[next.id]}'s turn! Pick a race.`);
  }
 
  renderAll();
}
 
function endGame() {
  state.phase = 'done';
  let best = state.players.reduce((a, b) => a.coins > b.coins ? a : b);
  showModal('üèÜ Game Over!', `
    ${state.players.map(p => `${PLAYER_NAMES[p.id]}: üí∞ ${p.coins} coins`).join('<br>')}
    <br><br><b>${PLAYER_NAMES[best.id]} wins with ${best.coins} coins!</b>
  `, [
    { text: 'üîÑ New Game', class: 'btn btn-primary', action: () => { hideModal(); startGame(); } }
  ]);
  renderAll();
}
 
// ==============================
//  MODALS
// ==============================
function showModal(title, body, buttons = []) {
  document.getElementById('modalTitle').innerHTML = title;
  document.getElementById('modalBody').innerHTML = body;
  const btnContainer = document.getElementById('modalButtons');
  btnContainer.innerHTML = '';
  buttons.forEach(b => {
    const btn = document.createElement('button');
    btn.className = b.class || 'btn btn-primary';
    btn.innerHTML = b.text;
    btn.style.margin = '4px';
    btn.addEventListener('click', b.action);
    btnContainer.appendChild(btn);
  });
  document.getElementById('modalOverlay').classList.add('active');
}
 
function hideModal() {
  document.getElementById('modalOverlay').classList.remove('active');
}
 
// ==============================
//  EVENT BINDINGS
// ==============================
btnDecline.addEventListener('click', () => {
  showModal('üíÄ Decline Race?', `Put your <b>${currentPlayer().activeRace.emoji} ${currentPlayer().activeRace.name}</b> in decline?<br>You'll need to pick a new race next.`, [
    { text: 'Yes, Decline', class: 'btn btn-danger', action: () => { hideModal(); declineRace(); endTurn(); } },
    { text: 'Cancel', class: 'btn btn-info', action: hideModal },
  ]);
});
 
btnEndTurn.addEventListener('click', () => {
  const p = currentPlayer();
  if (state.phase === 'redeploy' && p.activeTokens > 0) {
    // Auto-distribute remaining tokens
    const owned = getPlayerRegions(p.id);
    while (p.activeTokens > 0 && owned.length > 0) {
      owned.forEach(r => { if (p.activeTokens > 0) { r.tokens++; p.activeTokens--; } });
    }
    // Abandon empty
    getPlayerRegions(p.id).forEach(r => {
      if (r.tokens === 0) r.owner = -1;
    });
  }
  if (state.phase === 'conquer') {
    // Auto redeploy first
    startRedeploy();
    // Auto fill all regions with 1, dump rest on first
    const owned = getPlayerRegions(p.id);
    owned.forEach(r => { if (p.activeTokens > 0) { r.tokens = 1; p.activeTokens--; } });
    while (p.activeTokens > 0 && owned.length > 0) {
      owned.forEach(r => { if (p.activeTokens > 0) { r.tokens++; p.activeTokens--; } });
    }
    getPlayerRegions(p.id).forEach(r => { if (r.tokens === 0) r.owner = -1; });
    state.phase = 'conquer'; // Reset phase before ending
  }
  endTurn();
});
 
btnRedeploy.addEventListener('click', startRedeploy);
 
btnLastDie.addEventListener('click', attemptFinalDie);
 
// Intercept region clicks during final conquest
const origRegionClick = onRegionClick;
function onRegionClick(regId) {
  if (state.phase === 'final_conquest') {
    attemptFinalConquest(regId);
    return;
  }
  if (state.phase === 'conquer') {
    attemptConquest(regId);
  } else if (state.phase === 'redeploy') {
    attemptRedeploy(regId);
  } else {
    state.selectedRegion = regId;
    renderAll();
  }
}
 
// ==============================
//  START
// ==============================
function startGame() {
  buildMap();
  initPlayers();
  generateComboPool();
  state.turn = 1;
  state.currentPlayer = 0;
  state.phase = 'pick';
  state.conqueredThisTurn = 0;
  state.pillageCount = 0;
  state.firstConquests = 0;
  state.usedFinalDie = false;
  state.selectedRegion = -1;
  state.log = [];
  addLog('üèÅ Welcome to Small Worlds! Player 1, pick a race combo!');
  renderLegend();
  renderAll();
}
 
// Welcome modal
document.addEventListener('DOMContentLoaded', () => {
  showModal('‚öîÔ∏è Welcome to Small Worlds!', `
    <p>A board game of fantasy conquest for 2 players!</p>
    <ul style="text-align:left;margin:12px auto;max-width:340px;font-size:.88rem;">
      <li>üé¥ <b>Pick a Race+Power combo</b> (top ones cost coins)</li>
      <li>‚öîÔ∏è <b>Conquer regions</b> by spending tokens</li>
      <li>üîÑ <b>Redeploy</b> to rearrange your forces</li>
      <li>üé≤ <b>Final Conquest</b> ‚Äì roll the dice for one last attack</li>
      <li>üíÄ <b>Decline</b> your race when it's stretched thin</li>
      <li>üí∞ <b>Score coins</b> each turn for regions held</li>
    </ul>
    <p>Most coins after ${MAX_TURNS} turns wins!</p>
  `, [
    { text: '‚öîÔ∏è Start Game!', class: 'btn btn-success', action: () => { hideModal(); startGame(); } }
  ]);
});
</script>
</body>
</html>
